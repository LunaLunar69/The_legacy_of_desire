[gd_scene load_steps=16 format=3 uid="uid://bw0atc0j3jsdm"]

[ext_resource type="Texture2D" uid="uid://c0mktwixkew7g" path="res://Assets/Sprites/chadAttack/1.png" id="1_4qjco"]
[ext_resource type="Texture2D" uid="uid://qwy7r4rdwrsg" path="res://Assets/Sprites/chadWalkingBack/2.png" id="2_4qjco"]
[ext_resource type="Texture2D" uid="uid://oo0dxhgv1s2k" path="res://Assets/Sprites/chadAttack/2.png" id="2_smhpm"]
[ext_resource type="Texture2D" uid="uid://c1rx5so1ylcre" path="res://Assets/Sprites/chadWalkingSide/1.png" id="3_smhpm"]
[ext_resource type="Texture2D" uid="uid://cdk6ulbaw4avw" path="res://Assets/Sprites/chadWalkingFront/1.png" id="4_am38o"]
[ext_resource type="Texture2D" uid="uid://j73w770cj17r" path="res://Assets/Sprites/chadWalkingBack/1.png" id="5_dw42r"]
[ext_resource type="Texture2D" uid="uid://duum4uh8ax3d4" path="res://Assets/Sprites/chadWalkingBack/3.png" id="6_y7see"]
[ext_resource type="Texture2D" uid="uid://bljus7ylc0ew8" path="res://Assets/Sprites/chadWalkingFront/2.png" id="7_awxwk"]
[ext_resource type="Texture2D" uid="uid://c4awfyd4p7bou" path="res://Assets/Sprites/chadWalkingFront/3.png" id="8_u0bhs"]
[ext_resource type="Texture2D" uid="uid://bo50f1u251kid" path="res://Assets/Sprites/chadWalkingSide/2.png" id="9_vga1d"]
[ext_resource type="Texture2D" uid="uid://c56atgay6us22" path="res://Assets/Sprites/chadWalkingSide/3.png" id="10_aqnvw"]

[sub_resource type="GDScript" id="GDScript_setn8"]
script/source = "extends CharacterBody2D

# --- Variables Exportadas y Constantes ---
@export var SPEED: float = 250.0 
@onready var animated_sprite: AnimatedSprite2D = $AnimatedSprite2D
@onready var attack_hitbox: Area2D = $AttackHitbox # <--- ¡NUEVA LÍNEA! Referencia al nodo AttackHitbox

# Define los nombres de las animaciones que tienes en tu SpriteFrames:
const ANIM_WALK_BACK := \"walkfront\"
const ANIM_WALK_FRONT := \"walkback\"
const ANIM_WALK_SIDE := \"walkside\"
const ANIM_IDLE := \"walkfront\" 
const ANIM_ATTACK := \"attack\" 

var is_attacking: bool = false 

# --- FUNCIÓN DE INICIALIZACIÓN ---
func _ready():
	# Conectamos la señal para detectar colisiones con otros 'bodies'
	# Asegúrate de que el AttackHitbox esté conectado a esta función en el editor o aquí.
	if attack_hitbox and not attack_hitbox.body_entered.is_connected(_on_attack_hitbox_body_entered):
		attack_hitbox.body_entered.connect(_on_attack_hitbox_body_entered)
		
	# Desactivamos el hitbox al inicio
	attack_hitbox.monitorable = false # Monitorable: puede ser golpeado
	attack_hitbox.monitoring = false  # Monitoring: detecta golpes
	

# --- Detección de Entrada y Ataque (MODIFICADA) ---

func _unhandled_input(event: InputEvent) -> void:
	# 1. DETECCIÓN DE ATAQUE PRESIONADO (EMPEZAR EL ATAQUE)
	if event.is_action_pressed(\"attack\"): 
		if not is_attacking:
			is_attacking = true
			
			# Detenemos el movimiento
			velocity = Vector2.ZERO 
			move_and_slide()
			
			# Reproducimos la animación
			animated_sprite.play(ANIM_ATTACK)
			
			# ACTIVAR EL HITBOX AL INICIO DEL ATAQUE
			attack_hitbox.monitorable = true
			attack_hitbox.monitoring = true
			
			get_viewport().set_input_as_handled()
	
	# 2. DETECCIÓN DE ATAQUE LIBERADO (TERMINAR EL ATAQUE)
	if event.is_action_released(\"attack\"): 
		if is_attacking:
			is_attacking = false
			
			# DESACTIVAR EL HITBOX AL TERMINAR EL ATAQUE
			attack_hitbox.monitorable = false
			attack_hitbox.monitoring = false
			
			_update_idle_state()
			
			get_viewport().set_input_as_handled()

# --- Lógica de Detección de Colisión (NUEVA FUNCIÓN) ---

func _on_attack_hitbox_body_entered(body: Node2D) -> void:
	# Verificamos si Chad está atacando y si el cuerpo es un enemigo (usando el grupo \"enemies\")
	if is_attacking and body.is_in_group(\"enemies\"):
		# Intentamos llamar a la función de muerte del enemigo
		if body.has_method(\"take_hit_and_die\"):
			body.take_hit_and_die()
			
			# Desactivamos inmediatamente el hitbox para evitar múltiples golpes
			attack_hitbox.monitorable = false
			attack_hitbox.monitoring = false

# ... (El resto del código de _physics_process, _update_animations y _update_idle_state se mantiene igual)

func _physics_process(delta: float) -> void:
	# Si el personaje está atacando, salimos de la función para que NO se mueva
	if is_attacking:
		# Aseguramos que el personaje no se mueva mientras ataca
		velocity = Vector2.ZERO
		move_and_slide() 
		return

	# 1. Obtener la entrada del usuario
	var input_vector: Vector2 = Input.get_vector(\"ui_left\", \"ui_right\", \"ui_up\", \"ui_down\")
	
	if input_vector != Vector2.ZERO:
		# Si hay movimiento, normalizamos y aplicamos velocidad
		velocity = input_vector.normalized() * SPEED
		_update_animations(input_vector)
	else:
		velocity = Vector2.ZERO
		_update_idle_state()

	# 3. Mover el personaje
	move_and_slide()


# --- ELIMINAMOS la función _on_attack_animation_finished y _play_attack_animation ya no son necesarias.

# --- El resto del código de animación (_update_animations y _update_idle_state) queda igual ---

func _update_animations(input_vector: Vector2) -> void:
	# Comprobamos la dirección principal para decidir qué animación reproducir:
	
	if abs(input_vector.x) > abs(input_vector.y):
		# Movimiento Horizontal (Lados)
		animated_sprite.animation = ANIM_WALK_SIDE
		
		# Determinar la dirección horizontal y voltear el sprite (Flip H):
		if input_vector.x > 0:
			# Derecha
			animated_sprite.flip_h = false
		else:
			# Izquierda
			animated_sprite.flip_h = true
	
	else:
		# Movimiento Vertical (Arriba/Abajo)
		animated_sprite.flip_h = false # Quitamos el flip
		
		if input_vector.y > 0:
			# Abajo
			animated_sprite.animation = ANIM_WALK_FRONT
		else:
			# Arriba
			animated_sprite.animation = ANIM_WALK_BACK
			
	# Aseguramos que la animación se esté reproduciendo
	animated_sprite.play()


func _update_idle_state() -> void:
	# Si el personaje está inactivo, establecemos la animación IDLE.
	if animated_sprite.animation != ANIM_IDLE:
		animated_sprite.animation = ANIM_IDLE
		
	# Detenemos la animación y forzamos el Frame 0 (posición de reposo)
	animated_sprite.stop()
	animated_sprite.frame = 0
"

[sub_resource type="RectangleShape2D" id="RectangleShape2D_setn8"]
size = Vector2(50.999996, 38)

[sub_resource type="SpriteFrames" id="SpriteFrames_dts1y"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": ExtResource("1_4qjco")
}, {
"duration": 1.0,
"texture": ExtResource("2_smhpm")
}],
"loop": true,
"name": &"attack",
"speed": 8.0
}, {
"frames": [{
"duration": 1.0,
"texture": ExtResource("3_smhpm")
}, {
"duration": 1.0,
"texture": ExtResource("4_am38o")
}, {
"duration": 1.0,
"texture": ExtResource("5_dw42r")
}],
"loop": true,
"name": &"idle",
"speed": 3.0
}, {
"frames": [{
"duration": 1.0,
"texture": ExtResource("2_4qjco")
}, {
"duration": 1.0,
"texture": ExtResource("6_y7see")
}],
"loop": true,
"name": &"walkback",
"speed": 5.0
}, {
"frames": [{
"duration": 1.0,
"texture": ExtResource("7_awxwk")
}, {
"duration": 1.0,
"texture": ExtResource("8_u0bhs")
}],
"loop": true,
"name": &"walkfront",
"speed": 5.0
}, {
"frames": [{
"duration": 1.0,
"texture": ExtResource("9_vga1d")
}, {
"duration": 1.0,
"texture": ExtResource("10_aqnvw")
}],
"loop": true,
"name": &"walkside",
"speed": 5.0
}]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_4qjco"]
size = Vector2(96, 102.25)

[node name="Chad" type="CharacterBody2D"]
script = SubResource("GDScript_setn8")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(341.5, 82)
shape = SubResource("RectangleShape2D_setn8")

[node name="Camera2D" type="Camera2D" parent="."]
position = Vector2(340.4216, 19.212116)

[node name="AnimatedSprite2D" type="AnimatedSprite2D" parent="."]
position = Vector2(343, 68.00001)
scale = Vector2(0.66289747, 0.5664394)
sprite_frames = SubResource("SpriteFrames_dts1y")
animation = &"attack"
frame_progress = 0.88994056

[node name="AttackHitbox" type="Area2D" parent="."]
position = Vector2(341, 84)

[node name="CollisionShape2D" type="CollisionShape2D" parent="AttackHitbox"]
position = Vector2(1, -7.125)
shape = SubResource("RectangleShape2D_4qjco")
debug_color = Color(0.9761607, 0, 0.4175378, 0.41960785)
